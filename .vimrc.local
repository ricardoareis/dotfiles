" Basic properties {
" vim: set expandtab sw=4 ts=4 sts=4 tw=78 ft=vim foldmarker={,} foldlevel=0 foldmethod=marker spell:
"
" Note: Custom Maps
"
" <F1>      Open NERDTree
" <F2>      Open UndoTree
" <F3>      Open Tagbar
" <F8>      Shift Spell dictionaries
" <S-Tab>   Shift between buffers
" <Alt-(Left|Right)> (Next|Previous) Tab
" <Alt-(Up|Down)>     Move view to see (bellow|above) the cursor
"
" zfm                               Fold Method
" z<(Down|UP)>     (Next|Previous)  Fold
" z<(Right|Left)> (Close|Open)      Fold
" <C-x>    Toggle  (Open|Close)     Fold
"
" <C-p>     Fuzzy Finder
" <C-/>     Toggle   (On|Off)   Search Highlight
" <Alt-.>   Execute last :cmd

    " Use bundles config {
    if filereadable(expand("~/.vimrc.bundles"))
        source ~/.vimrc.bundles
    endif
    " }

    " SnipMate {
    " Setting the author var
    " If forking, please overwrite in your .vimrc.local file
    let g:snips_author = 'Ricardo Reis <ricardo.areis@gmail.com>'
    " }

    " Important Properties{

    set nocompatible                            " be iMproved, required"
    scriptencoding utf-8
    set encoding=utf-8
    set shell=$SHELL                            " Using default $SHELL

    " Config Clipboard {
    if has('clipboard')
        if has('unnamedplus')                   " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else                                    " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif
    " }

    syntax on
    filetype plugin indent on                   " Enable file type detection and do language dependent indenting

    set mouse=a                                 " Automatically enable mouse usage
    set mousehide                               " Hide the mouse cursor while typing

    set shortmess+=filmnrxoOtT                  " Abbrev. of messages (avoids 'hit enter')
    set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
    set virtualedit=onemore                     " Allow for cursor beyond last character

    set iskeyword-=.                            " '.' is an end of word
    set iskeyword-=#                            " '#' is an end of word
    set iskeyword-=-                            " '-' is an end of word

    set synmaxcol=500                          " Don't try to highlight lines longer than 5000 characters"

    set report=0                                " after yank/delete/... report number of lines affected
    set signcolumn=yes
    " set notimeout ttimeout ttimeoutlen=10     " Quickly time out on keycodes, but never timeout on mappings
    set ttimeoutlen=10
    set completeopt=longest,menuone,preview
    set switchbuf=useopen,usetab                " Attempt to edit currently open files instead of opening multiple buf
    set hidden                                  " Hide buffers when they are abandoned

    set wildmenu                                " enhanced command line completion
    set wildmode=list:longest:full              " complete files like a shell
    set scrolloff=10                            " lines of text around cursor
    set scrolljump=5                            " Lines to scroll when cursor leaves screen

    if has('cmdline_info')
        set ruler                               " Show the ruler
        set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
        set showcmd                             " Show partial commands in status line and
                                                " Selected characters/lines in visual mode
        set cmdheight=1                         " command bar height
    endif

    set laststatus=2                            " Always show the status line
    set noshowmode                              " Disabled default showmode
    set number relativenumber                   " Default relative number

    "https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
    set backspace=indent,eol,start              " Backspace for dummies (vim has a different approach)

    " Searching
    set ignorecase                              " case insensitive searching
    set smartcase                               " case-sensitive if expresson contains a capital letter
    set hlsearch                                " highlight search match
    set incsearch                               " set incremental search, like modern browsers
    set magic                                   " Set magic on, for regex

    " Performance Improving
    set re=1                                    " revert to regexp engine v1
    set ttyfast                                 " Improves screen redraw"
    set lazyredraw                              " Avoid redrawing the screen mid-command."

    " http://vim.wikia.com/wiki/Restore_cursor_to_file_position_in_previous_editing_session
    " Restore cursor to file position in previous editing session {
    function! ResCur()
        if line("'\"") <= line("$")
            silent! normal! g`"
            return 1
        endif
    endfunction
    augroup resCur
        autocmd!
        autocmd BufWinEnter * call ResCur()
    augroup END
    " }

    " changed the cursor behavior, in a edit, replace and append mode {
    " see autocmds.vim
    if empty($TMUX)
      let &t_SI = "\<Esc>]50;CursorShape=1\x7"
      let &t_EI = "\<Esc>]50;CursorShape=0\x7"
      let &t_SR = "\<Esc>]50;CursorShape=2\x7"
    else
      let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
      let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
      let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
    endif
    " }

    set cursorcolumn
    set backup                                  " Backups are nice ...
    if has('persistent_undo')
        set undofile                            " So is persistent undo ...
        set undolevels=10000                    " Maximum number of changes that can be undone
        set undoreload=10000                    " Maximum number lines to save for undo on a buffer reload
    endif

    " tmux will send xterm-style keys when its xterm-keys option is on
    if &term =~ '^xterm' || &term =~ '^screen' || &term =~ "^tmux"
        execute "set <xUp>=\e[1;*A"
        execute "set <xDown>=\e[1;*B"
        execute "set <xRight>=\e[1;*C"
        execute "set <xLeft>=\e[1;*D"
        "execute "set t_FI=\e[1;3D"
        "execute "set t_FJ=\e[1;3C"
    endif
    " }

    " Disable unused builtin plugins {
    let g:loaded_gzip              = 1
    let g:loaded_tar               = 1
    let g:loaded_tarPlugin         = 1
    let g:loaded_zip               = 1
    let g:loaded_zipPlugin         = 1
    let g:loaded_rrhelper          = 1
    let g:loaded_2html_plugin      = 1
    let g:loaded_vimball           = 1
    let g:loaded_vimballPlugin     = 1
    let g:loaded_getscript         = 1
    let g:loaded_getscriptPlugin   = 1
    let g:loaded_netrw             = 1
    let g:loaded_netrwPlugin       = 1
    let g:loaded_netrwSettings     = 1
    let g:loaded_netrwFileHandlers = 1
    let g:loaded_logipat           = 1
    " }

    " Color properties {
    if &term =~ '^xterm' || &term =~ '^screen' || &term =~ "^tmux"
        set t_Co=256                                " Enable 256 colors to stop the CSApprox warning and make xterm vim shine
    endif
    if exists('+termguicolors')                     " Only if compiled
      let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
      let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      set termguicolors
    endif
    set background=dark                             " Prefer Dark over Light
    let g:gruvbox_material_background='hard'        " Contrast Level
    colorscheme gruvbox-material                    " Using the same color scheme
    let g:gruvbox_termcolors=256                    " Accepting the 256 colors
    let g:gruvbox_material_enable_italic = 1        " Allow Italic fonts
    "}

    " Alerts and feedback properties {
    set noerrorbells
    set novisualbell
    set t_vb=                       "Never Flash de Screen"
    " }

    " Spell properties {
    set spelllang=en_us,pt
    "TODO: LOCAL DICT
    " }

    " Format properties {
    set autoindent        " Indent at the same level of the previous line
    set shiftwidth=4      " use indents of 4 spaces
    set expandtab         " tabs are spaces, not tabs
    set tabstop=4         " an indentation every four columns
    set softtabstop=4     " let backspace delete indent
    set nojoinspaces      " Prevents inserting two spaces after punctuation on a join (J)
    set splitright        " Puts new vsplit windows to the right of the current
    set splitbelow        " Puts new split windows to the bottom of the current
    "
    " Make it so AutoCloseTag works for xml and xhtml files as well
    au FileType xhtml,xml ru ftplugin/html/autoclosetag.vim
    nmap <Leader>ac <Plug>ToggleAutoCloseMappings
    " }

    " The complete properties {
    "
    " .: Scan the current buffer
    " w: Scan buffers from other windows
    " b: Scan buffers from the buffer list
    " u: Scan buffers that have been unloaded from the buffer list
    " t: Tag completion
    " i: Scan the current and included files
    "
    " see :set complet
    "
    set complete-=i   " disable scanning included files
    set complete-=t   " disable searching tags
    " }

    " WhichKey - Map {
    set timeoutlen=500
    let mapleader=","
    let maplocalleader=" "
    nnoremap <silent> <Leader>      :<c-u>WhichKey       ','<CR>
    vnoremap <silent> <leader>      :<c-u>WhichKeyVisual ','<CR>
    nnoremap <silent> <LocalLeader> :<c-u>WhichKey        '<Space>'<CR>
    vnoremap <silent> <LocalLeader> :<c-u>WhichKeyVisual  '<Space>'<CR>

    "Define prefix dictionary
    call which_key#register(',',       "g:which_key_leader_map")
    call which_key#register('<Space>', "g:which_key_localleader_map")

    let g:which_key_leader_map =  {}
    let g:which_key_localleader_map =  {}
    let g:which_key_leader_map.t = { 'name' : '+toggle' }
    let g:which_key_leader_map.f = { 'name' : '+find/files/fold' }
    let g:which_key_leader_map.e = { 'name' : '+edit' }
    let g:which_key_leader_map.y = { 'name' : '+go' }
    let g:which_key_leader_map.s = { 'name' : '+session' }
    let g:which_key_leader_map.g = { 'name' : '+git' }
    "let g:which_key_leader_map.c = { 'name' : '+commenter' }
    let g:which_key_leader_map.w = { 'name' : '+windows' }
    " }
" }

" Misc {

    " Show Invisible Chars {
    set nolist                                          " default disable
    if &encoding =~ 'utf-8'
        set listchars=eol:‚èé,tab:‚êâ¬∑,trail:‚ê†,nbsp:‚éµ       " default unicode
    endif
    " }

    " Dealing with a long lines properties {
    set wrap                                            " wrap long lines by default
    set whichwrap=b,s,h,l,<,>,[,]                       " Backspace and cursor keys wrap too
    set colorcolumn=120
    set showbreak=...
    " }

    " Vimdiff - Properties {
    "set diffopt=internal,algorithm:patience,indent-heuristic,horizontal
    set diffopt+=iwhite
    if has('nvim-0.3.2') || has("patch-8.1.0360")
        set diffopt=internal,filler,algorithm:histogram,indent-heuristic,horizontal
    endif
    if &diff
        map gs :call IwhiteToggle()<CR>
        function! IwhiteToggle()
            if &diffopt =~ 'iwhite'
                set diffopt-=iwhite
            else
                set diffopt+=iwhite
            endif
        endfunction
    endif
    " }

    " Conceal properties {
    if has('conceal')
        set conceallevel=0
        nnoremap coe :set <C-R>=&conceallevel ? 'conceallevel=0' : 'conceallevel=1'<CR><CR>
        "nmap <silent><unique> <Leader>tcoe :set <C-R>=&conceallevel ? 'conceallevel=0' : 'conceallevel=1'<CR><CR>
    endif
    " }

    " JSON {
    if has('python3')
        command! JSONPretty call FormatJson()
    else
        command! JSONPretty %!python -m json.tool
    endif
    nnoremap jp <Esc>:JSONPretty<CR><Esc>:set filetype=json<CR>
    let g:vim_json_syntax_conceal = 1
    " }

    " Wildfire {

    let g:wildfire_objects = {
                \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
                \ "html,xml" : ["at"],
                \ }


" }

" Maps {
    " The default leader is '\', but many people prefer ',' as it's in a standard

    " reload configuration
    nnoremap <Leader><Leader>r :source ~/.vimrc<CR>

    " Windows: Better split management, kept in sync with tmux' mappings {
    noremap <Leader>wh :sp<CR><C-w>j
    noremap <Leader>wv :vsp<CR><C-w>l
    let g:which_key_leader_map.w.h = 'Horizontal'
    let g:which_key_leader_map.w.v = 'Vertical'

        "Improve viewports {
        "map <Leader>w= <C-w>=
        "map <Leader>w_ <C-w>_
        "map <Leader>w+ <C-w>+
        "
        let g:which_key_leader_map['w'] = {
          \ 'name' : '+windows' ,
          \ 'w' : ['<C-W>w'     , 'other-window']          ,
          \ 'd' : ['<C-W>c'     , 'delete-window']         ,
          \ '-' : ['<C-W>s'     , 'split-window-below']    ,
          \ '|' : ['<C-W>v'     , 'split-window-right']    ,
          \ '2' : ['<C-W>v'     , 'layout-double-columns'] ,
          \ 'h' : ['<C-W>h'     , 'window-left']           ,
          \ 'j' : ['<C-W>j'     , 'window-below']          ,
          \ 'l' : ['<C-W>l'     , 'window-right']          ,
          \ 'k' : ['<C-W>k'     , 'window-up']             ,
          \ 'H' : ['<C-W>5<'    , 'expand-window-left']    ,
          \ 'J' : ['resize +5'  , 'expand-window-below']   ,
          \ 'L' : ['<C-W>5>'    , 'expand-window-right']   ,
          \ 'K' : ['resize -5'  , 'expand-window-up']      ,
          \ '=' : ['<C-W>='     , 'balance-window']        ,
          \ 's' : ['<C-W>s'     , 'split-window-below']    ,
          \ 'v' : ['<C-W>v'     , 'split-window-below']    ,
          \ '?' : ['Windows'    , 'fzf-window']            ,
          \ }
        " }

    " }

    " toggle cursor line {
    "nnoremap <Leader>tc :set cursorline!<CR>
    nnoremap <silent><unique> <Leader>tc :set cursorline!<CR>
    let g:which_key_leader_map.t.c = 'CursorLine'
    " }

    " scroll the view port faster {
    nnoremap <C-e> 3<C-e>
    nnoremap <C-y> 3<C-y>
    " }

    " buffer shortcuts {
    "TODO mv close then list properties, but it does not work
    nnoremap <silent><unique> <Leader>tl :set list!<CR>
    let g:which_key_leader_map.t.l = 'ListChars'
    "
    "Map <Alt-Tab>
    nnoremap <silent><S-Tab>  :bp<CR>
    "
    "TODO: probably it will be removed
    nnoremap <C-Left>  :bn<CR>
    nnoremap <C-Right> :bp<CR>
    let g:which_key_leader_map.b = {
      \ 'name' : '+buffer' ,
      \ '1' : ['b1'        , 'buffer 1']        ,
      \ '2' : ['b2'        , 'buffer 2']        ,
      \ 'd' : ['bd'        , 'delete-buffer']   ,
      \ 'f' : ['bfirst'    , 'first-buffer']    ,
      \ 'l' : ['blast'     , 'last-buffer']     ,
      \ 'n' : ['bnext'     , 'next-buffer']     ,
      \ 'p' : ['bprevious' , 'previous-buffer'] ,
      \ '?' : ['Buffers'   , 'fzf-buffer']      ,
      \ }
    " }

    " Map to move lines to bellow than current line {
    "
    "TODO: Refining this cmd, bellow to samples produced by me
    "nnoremap cp mc3kY'cP :delmark c<CR>
    "nnoremap <expr>cp 'mc'.nr2char(getchar())."kY'cP :delmark c"<CR>
    "nnoremap cp :exec    ("normal mc" . nr2char(getchar()) . "kY'c")<CR>
    "
    function! MvLines()
        let l:number = 2
        let l:string = ""
    "
        while l:number > 0
            let l:string .= nr2char(getchar())
            let l:number -= 1
        endwhile
    "
        return l:string . "m."
    endfunction
    "
    nnoremap mv :<C-u>execute MvLines()<CR>
    " }

    " Inconsistency: Fix {
    "
    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$
    nnoremap vv ^vg_
    nnoremap vV vg_
    vnoremap <Tab> >gv
    " }

    " Go to tab by number {
    "noremap <Leader>t1 1gt
    "noremap <Leader>t2 2gt
    "noremap <Leader>t3 3gt
    "noremap <Leader>t4 4gt
    "noremap <Leader>t5 5gt
    "noremap <Leader>t6 6gt
    "noremap <Leader>t7 7gt
    "noremap <Leader>t8 8gt
    "noremap <Leader>t9 9gt
    "noremap <Leader>t0 :tablast<CR>
    noremap <Esc>[1;3D :tabnext<CR>
    noremap <Esc>[1;3C :tabprevious<CR>
    " }

    " Code folding options {
    set foldenable
    set foldnestmax=10                              " deepest fold is 10 levels
    "
    "Jump between folding
    nnoremap z<Up> zk
    nnoremap z<Down> zj
    nnoremap z<Left> zc
    nnoremap z<Right> zo
    "TODO: review the map bellow
    noremap <C-x> :exec "normal zA"<CR>
    nmap <Leader>f0 :set foldlevel=0<CR>
    let g:which_key_leader_map.f.0 = '0-fold-level'
    nmap <Leader>f1 :set foldlevel=1<CR>
    let g:which_key_leader_map.f.1 = '1-fold-level'
    nmap <Leader>f2 :set foldlevel=2<CR>
    let g:which_key_leader_map.f.2 = '2-fold-level'
    nmap <Leader>f3 :set foldlevel=3<CR>
    let g:which_key_leader_map.f.3 = '3-fold-level'
    nmap <Leader>f4 :set foldlevel=4<CR>
    let g:which_key_leader_map.f.4 = '4-fold-level'
    nmap <Leader>f5 :set foldlevel=5<CR>
    let g:which_key_leader_map.f.5 = '5-fold-level'
    nmap <Leader>f6 :set foldlevel=6<CR>
    let g:which_key_leader_map.f.6 = '6-fold-level'
    nmap <Leader>f7 :set foldlevel=7<CR>
    let g:which_key_leader_map.f.7 = '7-fold-level'
    nmap <Leader>f8 :set foldlevel=8<CR>
    let g:which_key_leader_map.f.8 = '8-fold-level'
    nmap <Leader>f9 :set foldlevel=9<CR>
    let g:which_key_leader_map.f.9 = '9-fold-level'
    "
    set foldmethod=indent
    nnoremap <silent>cof :let &foldmethod = tolower(matchstr(
          \',mmanual,kmarker,iindent,ssyntax,eexpr,ddiff',
          \','.nr2char(getchar()).'\zs\a*\C'))\|set foldmethod<CR>
    nmap <silent>zfm cof
    " }

    " Most prefer to toggle search highlighting rather than clear the current {
    noremap    :set hlsearch! hlsearch?<CR>
    " }

    " Wrapped lines goes down/up to next row, rather than next line in file {
    noremap j gj
    noremap k gk
    noremap <Down> g<Down>
    noremap <Up> g<Up>
    " }

    " End/Start of line motion keys act relative to row/wrap width in the {
    " presence of `:set wrap`, and relative to line for `:set nowrap`.
    " Default vim behaviour is to act relative to text line in both cases
    function! WrapRelativeMotion(key, ...)
        let vis_sel=""
        if a:0
            let vis_sel="gv"
        endif
        if &wrap
            execute "normal!" vis_sel . "g" . a:key
        else
            execute "normal!" vis_sel . a:key
        endif
    endfunction

    " Map g* keys in Normal, Operator-pending, and Visual+select
    noremap $ :call WrapRelativeMotion("$")<CR>
    noremap <End> :call WrapRelativeMotion("$")<CR>
    noremap 0 :call WrapRelativeMotion("0")<CR>
    noremap <Home> :call WrapRelativeMotion("0")<CR>
    noremap ^ :call WrapRelativeMotion("^")<CR>
    " Overwrite the operator pending $/<End> mappings from above
    " to force inclusive motion with :execute normal!
    onoremap $ v:call WrapRelativeMotion("$")<CR>
    onoremap <End> v:call WrapRelativeMotion("$")<CR>
    " Overwrite the Visual+select mode mappings from above
    " to ensure the correct vis_sel flag is passed to function
    vnoremap $ :<C-u>call WrapRelativeMotion("$", 1)<CR>
    vnoremap <End> :<C-u>call WrapRelativeMotion("$", 1)<CR>
    vnoremap 0 :<C-u>call WrapRelativeMotion("0", 1)<CR>
    vnoremap <Home> :<C-u>call WrapRelativeMotion("0", 1)<CR>
    vnoremap ^ :<C-u>call WrapRelativeMotion("^", 1)<CR>
    " }

    " Visual shifting (does not exit Visual mode) {
    vnoremap < <gv
    vnoremap > >gv
    " }

    " Allow using the repeat operator with a visual selection (!) {
    " http://stackoverflow.com/a/8064607/127816
    vnoremap . :normal .<CR>
    " }

    " For when you forget to sudo.. Really Write the file. {
    cmap w!! w !sudo tee % >/dev/null
    " }

    " Some helpers to edit mode {
    " http://vimcasts.org/e/14
    cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<CR>
    " open in a new buffer
    map <Leader>ew :e %%
    let g:which_key_leader_map.e.w = 'NewFile'
    " open in a new horizontal window
    map <Leader>es :sp %%
    let g:which_key_leader_map.e.s = 'NewHorizontalWindow'
    " open in a new vertical window
    map <Leader>ev :vsp %%
    let g:which_key_leader_map.e.v = 'NewVerticalWindow'
    " open in a new tab
    map <Leader>et :tabe %%
    let g:which_key_leader_map.e.t = 'NewTab'
    " }


    " Jump to the middle of the current written line as opposed to the window width {
    nnoremap <silent> gm :call cursor(0, virtcol('$')/2)<CR>|nnoremap gM gm
    " }

    " Scroll relative to cursor (@_ suppresses [count] for zt) {
    " this cmd alternate between 10 lines bellow and above.
    " Use <expr> to increase or decrease
    nnoremap <expr><C-Up>   v:count > 0 ? '@_zt'.v:count.'<c-y>' : 'zt'
    nnoremap <expr><C-Down> v:count > 0 ? '@_zb'.v:count.'<c-e>' : 'zb'
    " }

    " Vim Terminal {
    nnoremap <Leader><Space> :terminal<CR>
    " }

    " Repeat the last command (ex. :ls) {
    " If your terminal print the same  for, both <Esc> and <Alt>
    " decide the best usability.
    nnoremap <Esc>. @:
    " }

" }

    " Unmaps {
    " STOP the help from being so... HELPFULL ;)
    inoremap <F1> <Esc>
    nnoremap <F1> <Esc>
    vnoremap <F1> <Esc>
    " }

" Funtions {

    " Initialize directories {
    function! InitializeDirectories()
        let parent = $HOME
        let prefix = 'vim'
        let dir_list = {
                    \ 'backup': 'backupdir',
                    \ 'views': 'viewdir',
                    \ 'swap': 'directory' }
        "
        if has('persistent_undo')
            let dir_list['undo'] = 'undodir'
        endif
        "
        let common_dir = parent . '/.' . prefix
        "
        for [dirname, settingname] in items(dir_list)
            let directory = common_dir . dirname . '/'
            if exists("*mkdir")
                if !isdirectory(directory)
                    call mkdir(directory)
                endif
            endif
            if !isdirectory(directory)
                echo "Warning: Unable to create backup directory: " . directory
                echo "Try: mkdir -p " . directory
            else
                let directory = substitute(directory, " ", "\\\\ ", "g")
                exec "set " . settingname . "=" . directory
            endif
        endfor
    endfunction
    call InitializeDirectories()
    " }

    " Initialize NERDTree as needed {
    function! NERDTreeInitAsNeeded()
        redir => bufoutput
        buffers!
        redir END
        let idx = stridx(bufoutput, "NERD_tree")
        if idx > -1
            NERDTreeMirror
            NERDTreeFind
            wincmd l
        endif
    endfunction
    " }

    " Strip whitespace {
    function! StripTrailingWhitespace()
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " do the business:
        %s/\s\+$//e
        " clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
    " }

    " Shell command {
    function! s:RunShellCommand(cmdline)
        botright new
        setlocal buftype=nofile
        setlocal bufhidden=delete
        setlocal nobuflisted
        setlocal noswapfile
        setlocal nowrap
        setlocal filetype=shell
        setlocal syntax=shell

        call setline(1, a:cmdline)
        call setline(2, substitute(a:cmdline, '.', '=', 'g'))
        execute 'silent $read !' . escape(a:cmdline, '%#')
        setlocal nomodifiable
        1
    endfunction
    "
    command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)
    " e.g. Grep current file for <search_term>: Shell grep -Hn <search_term> %
    " }

" }

"Plugins {

    " Plugin: YCM properties {
    if isdirectory(expand("~/.vim/bundle/YouCompleteMe"))
        let g:ycm_use_clangd = 0
        let g:ycm_global_ycm_extra_conf = '~/repos/dotfiles/.ycm_extra_conf.py'
        let g:ycm_autoclose_preview_window_after_completion=1
        "
        map <Leader>yc  :YcmCompleter GoToDefinitionElseDeclaration<CR>
        let g:which_key_leader_map.y.c = 'GoToDefinitionElseDeclaration'
        "
        "TODO: Review YCM ommifunc
        "
        " enable completion from tags
        let g:ycm_collect_identifiers_from_tags_files = 1
        "
        " Trigger configuration.
        " Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
        "
        let g:UltiSnipsExpandTrigger = '<C-j>'
        let g:UltiSnipsJumpForwardTrigger = '<C-j>'
        let g:UltiSnipsJumpBackwardTrigger = '<C-k>'
        " If you want :UltiSnipsEdit to split your window.
        let g:UltiSnipsEditSplit = "vertical"
        "
        " Disable the neosnippet preview candidate window
        " When enabled, there can be too much visual noise
        " especially when splits are used.
        set completeopt-=preview
    endif
    " }

    " Plugin: Identlines properties (this plugin change conceal properties) {
    if isdirectory(expand("~/.vim/bundle/vim-indent-guides/"))
        let g:indent_guides_default_mapping = 0
        let g:indent_guides_start_level = 2
        let g:indent_guides_guide_size = 1
        let g:indent_guides_enable_on_vim_startup = 1
        "
        nnoremap <silent><unique> <Leader>ti :IndentGuidesToggle<CR>
        let g:which_key_leader_map.t.i = 'IndentGuidesToggle'
    endif
    " }

    "" Plugin: Vimux Properties {
    "" Prompt for a command to run
    "if isdirectory(expand("~/.vim/bundle/vimux/"))
        "map <Leader><Leader>pc :VimuxPromptCommand<CR>

        "" Run last command executed by VimuxRunCommand
        "map <Leader><Leader>lc :VimuxRunLastCommand<CR>
    "endif
    "" }

    " Plugin: Airline properties {
    if isdirectory(expand("~/.vim/bundle/vim-airline/"))
        " TODO: https://jnrowe-vim.readthedocs.io
        let g:airline_powerline_fonts=1
        let g:airline_skip_empty_sections = v:true
        if isdirectory(expand("~/.vim/bundle/vim-airline-themes/"))
            let g:airline_extensions=['branch', 'localsearch', 'virtualenv', 'csv', 'bufferline',
                        \             'hunks', 'keymap', 'quickfix', 'ale', 'tagbar', 'term', 'undotree',
                        \             'whitespace', 'wordcount', 'ycm']
            if !exists('g:gruvbox_material')
                let g:airline_theme='gruvbox_material'
            endif
            if !exists('g:airline_powerline_fonts') && v:version >= 800 && has('signs')
                " Use the default set of separators with a few customizations
                let g:airline_left_sep='‚Ä∫'  " Slightly fancier than '>'
                let g:airline_right_sep='‚Äπ' " Slightly fancier than '<'
                let g:airline_symbols = {
                    \ 'branch': 'ÔÑ¶',
                    \ 'crypt': 'ÔÄ£',
                    \ 'linenr': '‚ò∞'',
                    \ 'maxlinenr': 'ÓÇ°',
                    \ 'modified': '+',
                    \ 'notexists': '…Ü',
                    \ 'paste': 'œÅ',
                    \ 'readonly': 'ÔÅû',
                    \ 'space': ' ',
                    \ 'spell': 'ÔÄ≠',
                    \ 'whitespace': 'Œû',
                \ }
            endif
        endif
    endif
    " }

    " Plugin: FZF (performs like CtrlP) {
    if isdirectory(expand("~/.vim/bundle/fzf/"))
        nnoremap <C-p> :Files<CR>
        let g:fzf_layout={ 'window': 'bot'.float2nr(&lines * 0.4).'new'  }
    endif
    " }

    " Plugin: Vim-Go properties {
    if isdirectory(expand("~/.vim/bundle/vim-go/"))
        let g:go_fmt_command="goimports" " format with goimports instead of gofmt
        let g:go_list_type = "quickfix"
        let g:go_version_warning = 0
        let g:go_fmt_fail_silently = 1
        let g:go_fmt_autosave=1          " disable fmt on save
    endif
    " }

    " Plugin: GitGutter properties {
    if isdirectory(expand("~/.vim/bundle/vim-gitgutter/"))
        set updatetime=500
        let g:gitgutter_enabled=1
        let g:gitgutter_map_keys=0
        let g:gitgutter_sign_allow_clobber=1
        let g:gitgutter_highlight_lines=0
        let g:gitgutter_highlight_linenrs=1
        let g:gitgutter_sign_added='ad'
        let g:gitgutter_sign_modified='md'
        let g:gitgutter_sign_removed='rd'
        let g:gitgutter_sign_removed_first_line='rf'
        let g:gitgutter_sign_modified_removed='mr'
        let g:gitgutter_max_signs=100
        set foldtext=gitgutter#fold#foldtext()
        map ghs :GitGutterStageHunk<CR>
        map ghu :GitGutterUndoHunk<CR>
        map ghf :GitGutterFold<CR>
        nmap ]h <Plug>(GitGutterNextHunk)
        nmap [h <Plug>(GitGutterPrevHunk)
    endif
    " }

    " Plugin: Vim-Ale properties {
    if isdirectory(expand("~/.vim/bundle/ale/"))
        let g:ale_lint_on_enter = 0
        let g:ale_lint_on_text_changed = 'never'
        let g:ale_lint_on_insert_leave = 0
        let g:ale_sign_column_always = 1
        let g:ale_keep_list_window_open = 0
        let g:ale_open_list = 0
        let g:ale_set_loclist = 0
        let g:ale_set_quickfix = 1
        nmap <silent> <C-k> <Plug>(ale_previous_wrap)
        nmap <silent> <C-j> <Plug>(ale_next_wrap)
        nmap <Leader><Leader>af <Plug>(ale_fix)
    endif
    " }

    " Plugin: EditorConfig properties {
    if isdirectory(expand("~/.vim/bundle/editorconfig/"))
        let g:EditorConfig_exclude_patterns = ['fugitive://.*', 'scp://.*']
    endif
    " }

    " Plugin: Session List {
    set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
    if isdirectory(expand("~/.vim/bundle/sessionman.vim/"))
        nnoremap <silent><Leader>sl :SessionList<CR><CR>
        let g:which_key_leader_map.s.l = 'List'
        "
        nnoremap <silent><Leader>ss :SessionSave<CR><CR>
        let g:which_key_leader_map.s.s = 'Save'
        "
        nnoremap <silent><Leader>sc :SessionClose<CR><CR>
        let g:which_key_leader_map.s.c = 'Close'
    endif
    " }

    " Plugin: Vim-GO {
    " Disable some vim-go properties to better cursorline performance
    if isdirectory(expand("~/.vim/bundle/vim-go/"))
        let g:go_highlight_space_tab_error=0
        let g:go_highlight_array_whitespace_error=0
        let g:go_highlight_trailing_whitespace_error=0
        let g:go_highlight_functions = 1
        let g:go_highlight_methods = 1
        let g:go_highlight_structs = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_build_constraints = 1
        let g:go_fmt_command = "goimports"
        "TODO: Evaluate the <Space> namespace
        autocmd Filetype go let g:which_key_localleader_map.g = { 'name' : '+Golang' }
        "
        autocmd Filetype go nmap <LocalLeader>gs <Plug>(go-implements)
        autocmd Filetype go let g:which_key_localleader_map.g.s = 'Go-Implements'
        "
        autocmd FileType go nmap <LocalLeader>gi <Plug>(go-info)
        autocmd Filetype go let g:which_key_localleader_map.g.i = 'Go-Info'
        "
        autocmd FileType go nmap <LocalLeader>ge <Plug>(go-rename)
        autocmd Filetype go let g:which_key_localleader_map.g.e = 'Go-Rename'
        "
        autocmd FileType go nmap <LocalLeader>gr <Plug>(go-run)
        autocmd Filetype go let g:which_key_localleader_map.g.r = 'Go-Run'
        "
        autocmd FileType go nmap <LocalLeader>gb <Plug>(go-build)
        autocmd Filetype go let g:which_key_localleader_map.g.b = 'Go-Build'
        "
        autocmd FileType go nmap <LocalLeader>gt <Plug>(go-test)
        autocmd Filetype go let g:which_key_localleader_map.g.t = 'Go-Test'
        "
        autocmd FileType go nmap <LocalLeader>gd <Plug>(go-doc)
        autocmd Filetype go let g:which_key_localleader_map.g.d = 'Go-Doc'
        "
        autocmd FileType go nmap <LocalLeader>gv <Plug>(go-doc-vertical)
        autocmd Filetype go let g:which_key_localleader_map.g.v = 'Go-Doc-Vertical'
        "
        autocmd FileType go nmap <LocalLeader>gc <Plug>(go-coverage)
        autocmd Filetype go let g:which_key_localleader_map.g.c = 'Go-Coverage'
    endif
    " }

    " Plugin: UndoTree properties {
    if isdirectory(expand("~/.vim/bundle/undotree/"))
        nnoremap <silent><F2> :UndotreeToggle<CR>
        let g:undotree_SetFocusWhenToggle=1
        let g:undotree_WindowLayout = 4
        let g:undotree_ShortIndicators = 1
        let g:undotree_DiffpanelHeight = 13
        let g:undotree_SplitWidth = 30
        let g:undotree_HighlightChangedWithSign = 1
        let g:undotree_DiffCommand = 'diff -pud --label earlier --label later'
        let g:undotree_HighlightChangedWithSign = 1
    endif
    " }

    " Plugin: Work space properties {
    if isdirectory(expand("~/.vim/bundle/vim-workspace"))
        nnoremap <silent><F4> :ToggleWorkspace<CR>
        let g:workspace_session_directory = $HOME . '/.vim/sessions/'
        let g:workspace_autosave_always = 0
        let g:workspace_autosave_ignore = ['gitcommit', 'gitrebase', 'nerdtree']
        let g:workspace_persist_undo_history = 0  " enabled = 1 (default), disabled = 0
    endif
    " }

    " Plugin: NerdTree properties{
    if isdirectory(expand("~/.vim/bundle/nerdtree"))
        nnoremap <silent><F1> :NERDTreeToggle<CR>
        let g:NERDShutUp=1
        let g:NERDTreeQuitOnOpen=1                      " close NERDTree after a file is opened
        let NERDTreeShowLineNumbers=1
        let NERDTreeMinimalUI=0
        let NERDTreeDirArrows=0
        let NERDTreeShowBookmarks=1
        let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
        let NERDTreeChDirMode=0
        let NERDTreeQuitOnOpen=1
        let NERDTreeMouseMode=2
        let NERDTreeShowHidden=1
        let NERDTreeKeepTreeInNewTab=1
        let g:nerdtree_tabs_open_on_gui_startup=0
        " expand to the path of the file in the current buffer
        nnoremap <silent> <Leader>ff :NERDTreeFind<CR>
        let g:which_key_leader_map.f.f = 'NERDTreeFind'
    endif
    " }

    " Plugin: TagBar properties {
    if isdirectory(expand("~/.vim/bundle/tagbar/"))
        nnoremap <silent> <F3> :TagbarToggle<CR>
        let g:tagbar_left=0
        let g:tagbar_autofocus=1
        let g:tagbar_compact=1
        let g:tagbar_autoclose=1
        "TODO: investigate git and tags
        set tags=./tags;/,~/.vimtags
        " Make tags placed in .git/tags file available in all levels of a repository
        let gitroot = substitute(system('git rev-parse --show-toplevel'), '[\n\r]', '', 'g')
        if gitroot != ''
            let &tags = &tags . ',' . gitroot . '/.git/tags'
        endif
    endif
    " }

    " Plugin: Rainbow {
    if isdirectory(expand("~/.vim/bundle/rainbow/"))
        let g:rainbow_active = 1                        " 0 if you want to enable it later via :RainbowToggle
    endif
    " }

    " Plugin: Fugitive {
    if isdirectory(expand("~/.vim/bundle/vim-fugitive/"))
        nnoremap <silent> <Leader>gs :Gstatus<CR>
        let g:which_key_leader_map.g.s = 'Gstatus'
        "
        nnoremap <silent> <Leader>gd :Gdiff<CR>
        let g:which_key_leader_map.g.d = 'Gdiff'
        "
        nnoremap <silent> <Leader>gc :Gcommit<CR>
        let g:which_key_leader_map.g.c = 'Gcommit'
        "
        nnoremap <silent> <Leader>gb :Gblame<CR>
        let g:which_key_leader_map.g.b = 'Gblame'
        "
        nnoremap <silent> <Leader>gl :Glog<CR>
        let g:which_key_leader_map.g.l = 'Glog'
        "
        nnoremap <silent> <Leader>gp :Git push<CR>
        let g:which_key_leader_map.g.p = 'Gpush'
        "
        nnoremap <silent> <Leader>gr :Gread<CR>
        let g:which_key_leader_map.g.r = 'Gread'
        "
        nnoremap <silent> <Leader>gw :Gwrite<CR>
        let g:which_key_leader_map.g.w = 'Gwrite'
        "
        nnoremap <silent> <Leader>ge :Gedit<CR>
        let g:which_key_leader_map.g.e = 'Gedit'
        "
        nnoremap <silent> <Leader>gi :Git add -p %<CR>
        let g:which_key_leader_map.g.i = 'Gadd -p %'
    endif
    " }

    " Plugin: Better-WhiteSpace {
    if isdirectory(expand("~/.vim/bundle/vim-better-whitespace/"))
        " Navigate vim-better-whitespace
        nnoremap ]w :NextTrailingWhitespace<CR>
        nnoremap [w :PrevTrailingWhitespace<CR>
        let g:strip_whitespace_on_save = 1
    endif
    " }

    " Plugin: LocalSearch {
    if isdirectory(expand("~/.vim/bundle/vim-localsearch/"))
        nmap <Leader>/ <Plug>localsearch_toggle
    endif
    " }

    " Plugin: Wordy {
    noremap  <silent> <F8> :<C-u>NextWordy<cr>
    xnoremap <silent> <F8> :<C-u>NextWordy<cr>
    inoremap <silent> <F8> <C-o>:NextWordy<cr>
    "]s	- Move to next misspelled word after the cursor.
    "[s	- Like ]s but search backwards
    " }

    "Plugin: Vim-repl - Python {
    if isdirectory(expand("~/.vim/bundle/vim-repl/"))
        let g:repl_program = {
                    \   'python': 'ipython',
                    \   'default': 'zsh',
                    \   'r': 'R',
                    \   'lua': 'lua',
                    \   'vim': 'vim -e',
                    \   }
        let g:repl_predefine_python = {
                    \   'numpy': 'import numpy as np',
                    \   'matplotlib': 'from matplotlib import pyplot as plt'
                    \   }
        let g:repl_cursor_down = 1
        let g:repl_python_automerge = 1
        let g:repl_ipython_version = '7.13.0'
        "let g:sendtorepl_invoke_key = "<LocalLeader>pw"
        let g:sendtorepl_invoke_key = ""
        "let g:which_key_localleader_map.p = { 'name' : '+Python' }

        autocmd Filetype python let g:which_key_localleader_map.p = { 'name' : '+Python' }
        autocmd Filetype python nnoremap <silent> <LocalLeader>pw  :SendCurrentLine<CR>
        autocmd Filetype python vnoremap <silent> <LocalLeader>pw  :SendLineToREPL<CR>
        autocmd Filetype python nnoremap <silent> <LocalLeader>pr  :REPLToggle<CR>
        autocmd Filetype python nnoremap <F10> <Esc>:REPLPDBN<CR>
        autocmd Filetype python nnoremap <F11> <Esc>:REPLPDBS<CR>
        autocmd Filetype python nnoremap <F12> <Esc>:REPLDebugStopAtCurrentLine<CR>
        let g:repl_position = 3
    endif
    "}

    " https://vimawesome.com/plugin/matchit-zip-the-story-of-us {
    if isdirectory(expand("~/.vim/bundle/matchit.zip"))
        let b:match_ignorecase = 1
    endif
    " }

    " Plugin: MarkerText {
    let g:SignatureMarkerTextHLDynamic=1
    " }
"}

" Loading others .vim {
" function to source in directory
for fpath in split(globpath('~/.vim/plugins.d/', '*.vim'), '\n')
    exe 'source' fpath
endfor
" }

" Basic properties {
" vim: set expandtab sw=4 ts=4 sts=4 tw=78 ft=vim foldmarker={,} foldlevel=0 foldmethod=marker spell:

    " Use bundles config {
    if filereadable(expand("~/.vimrc.bundles"))
        source ~/.vimrc.bundles
    endif
    " }

    " SnipMate {
    " Setting the author var
    " If forking, please overwrite in your .vimrc.local file
    let g:snips_author = 'Ricardo Reis <ricardo.areis@gmail.com>'
    " }

    " Important Properties{

    set nocompatible                            " be iMproved, required"
    scriptencoding utf-8
    set encoding=utf-8
    set shell=$SHELL                            " Using default $SHELL

    " Config Clipboard {
    if has('clipboard')
        if has('unnamedplus')                   " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else                                    " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif
    " }

    syntax on
    filetype plugin indent on                   " Enable file type detection and do language dependent indenting

    set mouse=a                                 " Automatically enable mouse usage
    set mousehide                               " Hide the mouse cursor while typing

    set shortmess+=filmnrxoOtT                  " Abbrev. of messages (avoids 'hit enter')
    set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
    set virtualedit=onemore                     " Allow for cursor beyond last character

    set iskeyword-=.                            " '.' is an end of word
    set iskeyword-=#                            " '#' is an end of word
    set iskeyword-=-                            " '-' is an end of word

    set synmaxcol=5000                          " Don't try to highlight lines longer than 5000 characters"

    set report=0                                " after yank/delete/... report number of lines affected
    set signcolumn=yes
    " set notimeout ttimeout ttimeoutlen=10     " Quickly time out on keycodes, but never timeout on mappings
    set ttimeoutlen=10
    set completeopt=longest,menuone,preview
    set switchbuf=useopen,usetab                " Attempt to edit currently open files instead of opening multiple buf
    set hidden                                  " Hide buffers when they are abandoned

    set wildmenu                                " enhanced command line completion
    set wildmode=list:longest:full              " complete files like a shell
    set scrolloff=10                            " lines of text around cursor
    set scrolljump=5                            " Lines to scroll when cursor leaves screen

    if has('cmdline_info')
        set ruler                               " Show the ruler
        set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
        set showcmd                             " Show partial commands in status line and
                                                " Selected characters/lines in visual mode
        set cmdheight=1                         " command bar height
    endif

    set laststatus=1                            " TODO: read manual
    set noshowmode                              " Disabled default showmode

    "https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
    set backspace=indent,eol,start              " Backspace for dummies (vim has a different approach)

    " Searching
    set ignorecase                              " case insensitive searching
    set smartcase                               " case-sensitive if expresson contains a capital letter
    set hlsearch                                " highlight search match
    set incsearch                               " set incremental search, like modern browsers
    set magic                                   " Set magic on, for regex

    " Performance Improving
    set re=1                                    " revert to regexp engine v1
    set ttyfast                                 " Improves screen redraw"
    set lazyredraw                              " Avoid redrawing the screen mid-command."

    " http://vim.wikia.com/wiki/Restore_cursor_to_file_position_in_previous_editing_session
    " Restore cursor to file position in previous editing session {
    function! ResCur()
        if line("'\"") <= line("$")
            silent! normal! g`"
            return 1
        endif
    endfunction
    augroup resCur
        autocmd!
        autocmd BufWinEnter * call ResCur()
    augroup END
    " }

    set backup                                  " Backups are nice ...
    if has('persistent_undo')
        set undofile                            " So is persistent undo ...
        set undolevels=10000                    " Maximum number of changes that can be undone
        set undoreload=10000                    " Maximum number lines to save for undo on a buffer reload
    endif

    " tmux will send xterm-style keys when its xterm-keys option is on
    if &term =~ '^tmux'
        execute "set <xUp>=\e[1;*A"
        execute "set <xDown>=\e[1;*B"
        execute "set <xRight>=\e[1;*C"
        execute "set <xLeft>=\e[1;*D"
    endif
    " }

    " Disable unused builtin plugins {
    let g:loaded_gzip              = 1
    let g:loaded_tar               = 1
    let g:loaded_tarPlugin         = 1
    let g:loaded_zip               = 1
    let g:loaded_zipPlugin         = 1
    let g:loaded_rrhelper          = 1
    let g:loaded_2html_plugin      = 1
    let g:loaded_vimball           = 1
    let g:loaded_vimballPlugin     = 1
    let g:loaded_getscript         = 1
    let g:loaded_getscriptPlugin   = 1
    let g:loaded_netrw             = 1
    let g:loaded_netrwPlugin       = 1
    let g:loaded_netrwSettings     = 1
    let g:loaded_netrwFileHandlers = 1
    let g:loaded_logipat           = 1
    " }

    " Color properties {
    if &term == 'xterm' || &term == 'screen' || &term == "^tmux"
        set t_Co=256                                " Enable 256 colors to stop the CSApprox warning and make xterm vim shine
    endif
    if exists('+termguicolors')                     " Only if compiled
      let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
      let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      set termguicolors
    endif
    set background=dark                             " Prefer Dark over Light
    let g:gruvbox_material_background='hard'        " Contrast Level
    colorscheme gruvbox-material                    " Using the same color scheme
    let g:gruvbox_termcolors=256                    " Accepting the 256 colors
    let g:gruvbox_material_enable_italic = 1        " Allow Italic fonts
    "}

    " Alerts and feedback properties {
    set noerrorbells
    set novisualbell
    set t_vb=                       "Never Flash de Screen"
    " }

    " Spell properties {
    set spelllang=en_us,pt
    "TODO: LOCAL DICT
    " }

    " Format properties {
    set autoindent        " Indent at the same level of the previous line
    set shiftwidth=4      " use indents of 4 spaces
    set expandtab         " tabs are spaces, not tabs
    set tabstop=4         " an indentation every four columns
    set softtabstop=4     " let backspace delete indent
    set nojoinspaces      " Prevents inserting two spaces after punctuation on a join (J)
    set splitright        " Puts new vsplit windows to the right of the current
    set splitbelow        " Puts new split windows to the bottom of the current
    "
    autocmd BufNewFile,BufRead *.html.twig set filetype=html.twig
    autocmd FileType haskell,puppet,ruby,yml setlocal expandtab shiftwidth=2 softtabstop=2
    autocmd BufNewFile,BufRead *.coffee set filetype=coffee
    "
    " Workaround vim-commentary for Haskell
    autocmd FileType haskell setlocal commentstring=--\ %s
    " Workaround broken colour highlighting in Haskell
    autocmd FileType haskell,rust setlocal nospell
    "
    " AutoCloseTag
    "
    " Make it so AutoCloseTag works for xml and xhtml files as well
    au FileType xhtml,xml ru ftplugin/html/autoclosetag.vim
    nmap <Leader>ac <Plug>ToggleAutoCloseMappings
    " }

    " The complete properties {
    "
    " .: Scan the current buffer
    " w: Scan buffers from other windows
    " b: Scan buffers from the buffer list
    " u: Scan buffers that have been unloaded from the buffer list
    " t: Tag completion
    " i: Scan the current and included files
    "
    " see :set complet
    "
    set complete-=i   " disable scanning included files
    set complete-=t   " disable searching tags
    " }

    " Code folding properties - TODO {
    set foldenable
    set foldmethod=indent
    set foldnestmax=10          " deepest fold is 10 levels
    noremap <C-x> :exec "normal zA"<CR>
    " }

" }

" Misc {

    " Show Invisible Chars {
    set nolist                                          " default disable
    set listchars=eol:⏎,tab:␉·,trail:␠,nbsp:⎵           " default unicode
    nmap <leader>l :set list!<cr>
    " }

    " Dealing with a long lines properties {
    set wrap                                            " wrap long lines by default
    set whichwrap=b,s,h,l,<,>,[,]                       " Backspace and cursor keys wrap too
    set colorcolumn=120
    autocmd VimResized * | set columns=120
    set showbreak=...
    " }

    " Vimdiff - Properties {
    set diffopt=internal,algorithm:patience,indent-heuristic
    "
    if &diff
        map gs :call IwhiteToggle()<CR>
        function! IwhiteToggle()
            if &diffopt =~ 'iwhite'
                set diffopt-=iwhite
            else
                set diffopt+=iwhite
            endif
        endfunction
    endif
    " }

    " Conceal properties {
    if has('conceal')
        set conceallevel=0
        nnoremap coe :set <C-R>=&conceallevel ? 'conceallevel=0' : 'conceallevel=1'<CR><CR>
    endif
    " }

    " JSON {
    nnoremap jt <Esc>:%!python -m json.tool<CR><Esc>:set filetype=json<CR>
    let g:vim_json_syntax_conceal = 1
    " }

    " Wildfire {

    let g:wildfire_objects = {
                \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
                \ "html,xml" : ["at"],
                \ }

    "TODO: GIT SUBMODULES
    if isdirectory(expand("~/.vim/bundle/matchit.zip"))
        let b:match_ignorecase = 1
    endif

" }

" Maps {
"
    " The default leader is '\', but many people prefer ',' as it's in a standard
    let mapleader=","

    " reload configuration
    nnoremap <leader><leader>r :source ~/.vimrc<CR>

    " Better split management, kept in sync with tmux' mappings
    noremap <leader>h :sp<CR><C-w>j
    noremap <leader>v :vsp<CR><C-w>l

    " toggle cursor line
    nnoremap <leader>i :set cursorline!<cr>

    " scroll the view port faster {
    nnoremap <C-e> 3<C-e>
    nnoremap <C-y> 3<C-y>
    " }

    " buffer shortcuts {
    nmap <leader>n :bn<cr> " go to next buffer
    nmap <leader>p :bp<cr> " go to prev buffers
    nmap <leader>q :bd<cr> " close the current buffer
    nnoremap <leader>ls :ls<cr>:b<space>
    " }

    " Inconsistency: Fix {
    "
    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$
    " }

    " Go to tab by number {
    noremap <leader>t1 1gt
    noremap <leader>t2 2gt
    noremap <leader>t3 3gt
    noremap <leader>t4 4gt
    noremap <leader>t5 5gt
    noremap <leader>t6 6gt
    noremap <leader>t7 7gt
    noremap <leader>t8 8gt
    noremap <leader>t9 9gt
    noremap <leader>t0 :tablast<cr>
    nnoremap <C-Left> :tabprevious<CR>
    nnoremap <C-Right> :tabnext<CR>
    " }

    " Code folding options {
    nmap <leader>f0 :set foldlevel=0<CR>
    nmap <leader>f1 :set foldlevel=1<CR>
    nmap <leader>f2 :set foldlevel=2<CR>
    nmap <leader>f3 :set foldlevel=3<CR>
    nmap <leader>f4 :set foldlevel=4<CR>
    nmap <leader>f5 :set foldlevel=5<CR>
    nmap <leader>f6 :set foldlevel=6<CR>
    nmap <leader>f7 :set foldlevel=7<CR>
    nmap <leader>f8 :set foldlevel=8<CR>
    nmap <leader>f9 :set foldlevel=9<CR>
    " }

    " Most prefer to toggle search highlighting rather than clear the current
    noremap <space> :set hlsearch! hlsearch?<cr>

    " Wrapped lines goes down/up to next row, rather than next line in file {
    noremap j gj
    noremap k gk
    noremap <Down> g<Down>
    noremap <Up> g<Up>
    " }

    " End/Start of line motion keys act relative to row/wrap width in the {
    " presence of `:set wrap`, and relative to line for `:set nowrap`.
    " Default vim behaviour is to act relative to text line in both cases
    function! WrapRelativeMotion(key, ...)
        let vis_sel=""
        if a:0
            let vis_sel="gv"
        endif
        if &wrap
            execute "normal!" vis_sel . "g" . a:key
        else
            execute "normal!" vis_sel . a:key
        endif
    endfunction

    " Map g* keys in Normal, Operator-pending, and Visual+select
    noremap $ :call WrapRelativeMotion("$")<CR>
    noremap <End> :call WrapRelativeMotion("$")<CR>
    noremap 0 :call WrapRelativeMotion("0")<CR>
    noremap <Home> :call WrapRelativeMotion("0")<CR>
    noremap ^ :call WrapRelativeMotion("^")<CR>
    " Overwrite the operator pending $/<End> mappings from above
    " to force inclusive motion with :execute normal!
    onoremap $ v:call WrapRelativeMotion("$")<CR>
    onoremap <End> v:call WrapRelativeMotion("$")<CR>
    " Overwrite the Visual+select mode mappings from above
    " to ensure the correct vis_sel flag is passed to function
    vnoremap $ :<C-U>call WrapRelativeMotion("$", 1)<CR>
    vnoremap <End> :<C-U>call WrapRelativeMotion("$", 1)<CR>
    vnoremap 0 :<C-U>call WrapRelativeMotion("0", 1)<CR>
    vnoremap <Home> :<C-U>call WrapRelativeMotion("0", 1)<CR>
    vnoremap ^ :<C-U>call WrapRelativeMotion("^", 1)<CR>
    " }

    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    " Allow using the repeat operator with a visual selection (!)
    " http://stackoverflow.com/a/8064607/127816
    vnoremap . :normal .<CR>

    " For when you forget to sudo.. Really Write the file.
    cmap w!! w !sudo tee % >/dev/null

    " Some helpers to edit mode {
    " http://vimcasts.org/e/14
    cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
    map <leader>ew :e %%
    map <leader>es :sp %%
    map <leader>ev :vsp %%
    map <leader>et :tabe %%
    " }

    " Adjust viewports to the same size
    map <Leader>= <C-w>=

    " Easier formatting
    nnoremap <silent> <leader>q gwip

    " LocalSearch
    nmap <leader>/ <Plug>localsearch_toggle

" }

    " Unmaps {
    " STOP the help from being so... HELPFULL ;)
    inoremap <F1> <ESC>
    nnoremap <F1> <ESC>
    vnoremap <F1> <ESC>
    " }

" Funtions {

    " Initialize directories {
    function! InitializeDirectories()
        let parent = $HOME
        let prefix = 'vim'
        let dir_list = {
                    \ 'backup': 'backupdir',
                    \ 'views': 'viewdir',
                    \ 'swap': 'directory' }
        "
        if has('persistent_undo')
            let dir_list['undo'] = 'undodir'
        endif
        "
        let common_dir = parent . '/.' . prefix
        "
        for [dirname, settingname] in items(dir_list)
            let directory = common_dir . dirname . '/'
            if exists("*mkdir")
                if !isdirectory(directory)
                    call mkdir(directory)
                endif
            endif
            if !isdirectory(directory)
                echo "Warning: Unable to create backup directory: " . directory
                echo "Try: mkdir -p " . directory
            else
                let directory = substitute(directory, " ", "\\\\ ", "g")
                exec "set " . settingname . "=" . directory
            endif
        endfor
    endfunction
    call InitializeDirectories()
    " }

    " Initialize NERDTree as needed {
    function! NERDTreeInitAsNeeded()
        redir => bufoutput
        buffers!
        redir END
        let idx = stridx(bufoutput, "NERD_tree")
        if idx > -1
            NERDTreeMirror
            NERDTreeFind
            wincmd l
        endif
    endfunction
    " }

    " Strip whitespace {
    function! StripTrailingWhitespace()
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " do the business:
        %s/\s\+$//e
        " clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
    " }

    " Shell command {
    function! s:RunShellCommand(cmdline)
        botright new
        setlocal buftype=nofile
        setlocal bufhidden=delete
        setlocal nobuflisted
        setlocal noswapfile
        setlocal nowrap
        setlocal filetype=shell
        setlocal syntax=shell

        call setline(1, a:cmdline)
        call setline(2, substitute(a:cmdline, '.', '=', 'g'))
        execute 'silent $read !' . escape(a:cmdline, '%#')
        setlocal nomodifiable
        1
    endfunction
    "
    command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)
    " e.g. Grep current file for <search_term>: Shell grep -Hn <search_term> %
    " }

" }

"Plugins {
    " Plugin: YCM properties {
    if isdirectory(expand("~/.vim/bundle/YouCompleteMe"))
        let g:ycm_use_clangd=0
        let g:ycm_global_ycm_extra_conf='~/repos/dotfiles/.ycm_extra_conf.py'
        let g:ycm_autoclose_preview_window_after_completion=1
        map <leader>gg  :YcmCompleter GoToDefinitionElseDeclaration<CR>
        "
        "TODO: Review bellow - SPF13 config
        let g:acp_enableAtStartup = 0
        "
        " enable completion from tags
        let g:ycm_collect_identifiers_from_tags_files = 1
        "
        " remap Ultisnips for compatibility for YCM
        let g:UltiSnipsExpandTrigger = '<C-j>'
        let g:UltiSnipsJumpForwardTrigger = '<C-j>'
        let g:UltiSnipsJumpBackwardTrigger = '<C-k>'
        "
        " Enable omni completion.
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
        " Haskell post write lint and check with ghcmod
        " $ `cabal install ghcmod` if missing and ensure
        " ~/.cabal/bin is in your $PATH.
        if !executable("ghcmod")
            autocmd BufWritePost *.hs GhcModCheckAndLintAsync
        endif
        " Disable the neosnippet preview candidate window
        " When enabled, there can be too much visual noise
        " especially when splits are used.
        set completeopt-=preview
    endif
    " }

    " Plugin: Identlines properties (this plugin change conceal properties) {
    if isdirectory(expand("~/.vim/bundle/vim-indent-guides/"))
        let g:indentLine_enabled=0
        let g:indentLine_setConceal=1
        let g:indent_guides_start_level = 2
        let g:indent_guides_guide_size = 1
        let g:indent_guides_enable_on_vim_startup = 1
    endif
    " }

    " Plugin: Vimux Properties {
    " Prompt for a command to run
    map <Leader><Leader>c :VimuxPromptCommand<CR>

    " Run last command executed by VimuxRunCommand
    map <Leader><Leader>cl :VimuxRunLastCommand<CR>
    " }

    " Plugin: Airline properties {
    if isdirectory(expand("~/.vim/bundle/vim-airline/"))
        let g:airline_powerline_fonts=1
        if isdirectory(expand("~/.vim/bundle/vim-airline-themes/"))
            if !exists('g:gruvbox_material')
                let g:airline_theme='gruvbox_material'
            endif
            if !exists('g:airline_powerline_fonts')
                " Use the default set of separators with a few customizations
                let g:airline_left_sep='›'  " Slightly fancier than '>'
                let g:airline_right_sep='‹' " Slightly fancier than '<'
            endif
        endif
        let g:airline#extensions#keymap#enabled=1
        let g:airline_extensions=['branch', 'localsearch', 'virtualenv', 'csv', 'bufferline', 'hunks', 'keymap', 'quickfix', 'ale', 'tagbar', 'term', 'undotree', 'whitespace', 'wordcount', 'ycm']
    endif
    " }

    " Plugin: FZF (performs like CtrlP) {
    nnoremap <C-p> :Files<CR>
    let g:fzf_layout={ 'window': 'bot'.float2nr(&lines * 0.4).'new'  }
    " }

    " Plugin: Vim-Go properties {
    let g:go_fmt_command="goimports" " format with goimports instead of gofmt
    let g:go_list_type = "quickfix"
    let g:go_version_warning = 0
    let g:go_fmt_fail_silently = 1
    let g:go_fmt_autosave=1          " disable fmt on save
    " }

    " Plugin: GitGutter properties {
    let g:gitgutter_enabled=1
    let g:gitgutter_map_keys=0
    let g:gitgutter_sign_allow_clobber=1
    let g:gitgutter_highlight_lines=0
    let g:gitgutter_highlight_linenrs=1
    let g:gitgutter_sign_added='ad'
    let g:gitgutter_sign_modified='md'
    let g:gitgutter_sign_removed='rd'
    let g:gitgutter_sign_removed_first_line='rf'
    let g:gitgutter_sign_modified_removed='mr'
    let g:gitgutter_max_signs=50
    set updatetime=2000
    set foldtext=gitgutter#fold#foldtext()
    map ghs :GitGutterStageHunk<CR>
    map ghu :GitGutterUndoHunk<CR>
    map ghf :GitGutterFold<CR>
    " }

    " Plugin: Vim-Ale properties {
    let g:ale_lint_on_enter = 0
    let g:ale_lint_on_text_changed = 'never'
    let g:ale_lint_on_insert_leave = 0
    let g:ale_sign_column_always = 1
    let g:ale_keep_list_window_open = 0
    let g:ale_open_list = 0
    let g:ale_set_loclist = 0
    let g:ale_set_quickfix = 1
    nmap <silent> <C-k> <Plug>(ale_previous_wrap)
    nmap <silent> <C-j> <Plug>(ale_next_wrap)
    nmap <Leader><Leader>af <Plug>(ale_fix)
    " }

    " Plugin: EditorConfig properties {
    let g:EditorConfig_exclude_patterns = ['fugitive://.*', 'scp://.*']
    " }

    " Plugin: Session List {
    set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
    if isdirectory(expand("~/.vim/bundle/sessionman.vim/"))
        nmap <leader>sl :SessionList<CR>
        nmap <leader>ss :SessionSave<CR>
        nmap <leader>sc :SessionClose<CR>
    endif
    " }

    " Plugin: Vim-GO {
    " Disable some vim-go properties to better cursorline performance
    let g:go_highlight_space_tab_error=0
    let g:go_highlight_array_whitespace_error=0
    let g:go_highlight_trailing_whitespace_error=0
    "TODO SPF13-VIM
    let g:go_highlight_functions = 1
    let g:go_highlight_methods = 1
    let g:go_highlight_structs = 1
    let g:go_highlight_operators = 1
    let g:go_highlight_build_constraints = 1
    let g:go_fmt_command = "goimports"
    "au FileType go nmap <Leader>s <Plug>(go-implements)
    "au FileType go nmap <Leader>i <Plug>(go-info)
    "au FileType go nmap <Leader>e <Plug>(go-rename)
    "au FileType go nmap <leader>r <Plug>(go-run)
    "au FileType go nmap <leader>b <Plug>(go-build)
    "au FileType go nmap <leader>t <Plug>(go-test)
    "au FileType go nmap <Leader>gd <Plug>(go-doc)
    "au FileType go nmap <Leader>gv <Plug>(go-doc-vertical)
    "au FileType go nmap <leader>co <Plug>(go-coverage)
    " }

    " Plugin: UndoTree properties {
    if isdirectory(expand("~/.vim/bundle/undotree/"))
        nnoremap <leader>uu :UndotreeToggle<cr>
        " If undotree is opened, it is likely one wants to interact with it.
        let g:undotree_SetFocusWhenToggle=1
        let g:gundo_right = 0
        let g:gundo_preview_bottom=1
        let g:gundo_preview_height = 50
    endif
    " }

    " Plugin: Work space properties {
    nnoremap <leader>w :ToggleWorkspace<CR>
    let g:workspace_session_directory = $HOME . '/.vim/sessions/'
    let g:workspace_autosave_always = 0
    let g:workspace_autosave_ignore = ['gitcommit', 'gitrebase', 'nerdtree']
    let g:workspace_persist_undo_history = 0  " enabled = 1 (default), disabled = 0
    " }

    " Plugin: NerdTree properties{
    if isdirectory(expand("~/.vim/bundle/nerdtree"))
        "map <C-e> <plug>NERDTreeTabsToggle<CR>
        "map <leader>e :NERDTreeFind<CR>
        "nmap <leader>nt :NERDTreeFind<CR>
        let g:NERDShutUp=1
        let g:NERDTreeQuitOnOpen=1                      " close NERDTree after a file is opened
        let NERDTreeShowLineNumbers=1
        let NERDTreeMinimalUI=0
        let NERDTreeDirArrows=0
        let NERDTreeShowBookmarks=1
        let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
        let NERDTreeChDirMode=0
        let NERDTreeQuitOnOpen=1
        let NERDTreeMouseMode=2
        let NERDTreeShowHidden=1
        let NERDTreeKeepTreeInNewTab=1
        let g:nerdtree_tabs_open_on_gui_startup=0
        nnoremap <silent> <leader>ff :NERDTreeFind<cr>  " expand to the path of the file in the current buffer
    endif
    " }

    " Plugin: TagBar properties {
    if isdirectory(expand("~/.vim/bundle/tagbar/"))
        nnoremap <silent> <leader>tt :TagbarToggle<CR>
        let g:tagbar_left=0
        let g:tagbar_autofocus=1
        let g:tagbar_compact=1
        let g:tagbar_autoclose=1
        "TODO: investigate git and tags
        set tags=./tags;/,~/.vimtags
        " Make tags placed in .git/tags file available in all levels of a repository
        let gitroot = substitute(system('git rev-parse --show-toplevel'), '[\n\r]', '', 'g')
        if gitroot != ''
            let &tags = &tags . ',' . gitroot . '/.git/tags'
        endif
    endif
    " }

    " Plugin: Rainbow {
    if isdirectory(expand("~/.vim/bundle/rainbow/"))
        let g:rainbow_active = 1                        " 0 if you want to enable it later via :RainbowToggle
    endif
    " }

    " Plugin: Fugitive {
    if isdirectory(expand("~/.vim/bundle/vim-fugitive/"))
        nnoremap <silent> <leader>gs :Gstatus<CR>
        nnoremap <silent> <leader>gd :Gdiff<CR>
        nnoremap <silent> <leader>gc :Gcommit<CR>
        nnoremap <silent> <leader>gb :Gblame<CR>
        nnoremap <silent> <leader>gl :Glog<CR>
        nnoremap <silent> <leader>gp :Git push<CR>
        nnoremap <silent> <leader>gr :Gread<CR>
        nnoremap <silent> <leader>gw :Gwrite<CR>
        nnoremap <silent> <leader>ge :Gedit<CR>
        " Mnemonic _i_nteractive
        nnoremap <silent> <leader>gi :Git add -p %<CR>
        nnoremap <silent> <leader>gg :SignifyToggle<CR>
    endif
    " }

    " Plugin: Better-WhiteSpace {
    if isdirectory(expand("~/.vim/bundle/vim-better-whitespace/"))
        " Navigate vim-better-whitespace
        nnoremap ]w :NextTrailingWhitespace<CR>
        nnoremap [w :PrevTrailingWhitespace<CR>
        let g:strip_whitespace_on_save = 1
    endif
    " }

"}

" Loading others .vim {
" function to source in directory
for fpath in split(globpath('~/.vim/plugins.d/', '*.vim'), '\n')
    exe 'source' fpath
endfor
"}
